[TOC]



# Протокол HTTP

**HTTP** (HyperText Transfer Protocol — протокол передачи гипертекста) — символьно-ориентированный клиент-серверный протокол прикладного уровня без сохранения состояния, используемый сервисом World Wide Web.

Основным объектом манипуляции в HTTP является ресурс, на который указывает URI (Uniform Resource Identifier – уникальный идентификатор ресурса) в запросе клиента. Основными ресурсами являются хранящиеся на сервере файлы, но ими могут быть и другие логические (напр. каталог на сервере) или абстрактные объекты (напр. ISBN). Протокол HTTP позволяет указать способ представления (кодирования) одного и того же ресурса по различным параметрам: mime-типу, языку и т. д. Благодаря этой возможности клиент и веб-сервер могут обмениваться двоичными данными, хотя данный протокол является текстовым.

## Структура протокола

Структура протокола определяет, что каждое HTTP-сообщение состоит из трёх частей (рис. 1), которые передаются в следующем порядке:

1. Стартовая строка (англ. Starting line) — определяет тип сообщения;
2. Заголовки (англ. Headers) — характеризуют тело сообщения, параметры передачи и прочие сведения;
3. Тело сообщения (англ. Message Body) — непосредственно данные сообщения. Обязательно должно отделяться от заголовков пустой строкой.

![../_images/wireshark-http-response.png](https://iit-web-lectures.readthedocs.io/ru/latest/_images/wireshark-http-response.png)

Рис. 1. Структура протокола HTTP (дамп пакета, полученный сниффером Wireshark)

## Стартовая строка HTTP

Cтартовая строка является обязательным элементом, так как указывает на тип запроса/ответа, заголовки и тело сообщения могут отсутствовать.

Стартовые строки различаются для запроса и ответа. **Строка запроса** выглядит так:

> Метод URI HTTP/Версия протокола

Пример запроса:

> GET /web-programming/index.html HTTP/1.1

Стартовая **строка ответа** сервера имеет следующий формат:

> HTTP/Версия КодСостояния [Пояснение]

Например, на предыдущий наш запрос клиентом данной страницы сервер ответил строкой:

> HTTP/1.1 200 Ok

### Методы протокола

Метод HTTP (англ. HTTP Method) — последовательность из любых символов, кроме управляющих и разделителей, указывающая на основную операцию над ресурсом. Обычно метод представляет собой короткое английское слово, записанное заглавными буквами (Табл. 1). Названия метода чувствительны к регистру.

Таблица 1. Методы протокола HTTP

| Метод       | Краткое описание                                             |
| :---------- | :----------------------------------------------------------- |
| **OPTIONS** | Используется для определения возможностей веб-сервера или параметров соединения для конкретного ресурса. Предполагается, что запрос клиента может содержать тело сообщения для указания интересующих его сведений. Формат тела и порядок работы с ним в настоящий момент не определён. Сервер пока должен его игнорировать. Аналогичная ситуация и с телом в ответе сервера.Для того чтобы узнать возможности всего сервера, клиент должен указать в URI звёздочку — «*». Запросы «OPTIONS * HTTP/1.1» могут также применяться для проверки работоспособности сервера (аналогично «пингованию») и тестирования на предмет поддержки сервером протокола HTTP версии 1.1.Результат выполнения этого метода не кэшируется. |
| **GET**     | Используется для запроса содержимого указанного ресурса. С помощью метода GET можно также начать какой-либо процесс. В этом случае в тело ответного сообщения следует включить информацию о ходе выполнения процесса. Клиент может передавать параметры выполнения запроса в URI целевого ресурса после символа «?»: GET /path/resource?param1=value1¶m2=value2 HTTP/1.1Согласно стандарту HTTP, запросы типа GET считаются идемпотентными[4] — многократное повторение одного и того же запроса GET должно приводить к одинаковым результатам (при условии, что сам ресурс не изменился за время между запросами). Это позволяет кэшировать ответы на запросы GET.Кроме обычного метода GET, различают ещё условный GET и частичный GET. Условные запросы GET содержат заголовки If-Modified-Since, If-Match, If-Range и подобные. Частичные GET содержат в запросе Range. Порядок выполнения подобных запросов определён стандартами отдельно. |
| **HEAD**    | Аналогичен методу GET, за исключением того, что в ответе сервера отсутствует тело. Запрос HEAD обычно применяется для извлечения метаданных, проверки наличия ресурса (валидация URL) и чтобы узнать, не изменился ли он с момента последнего обращения.Заголовки ответа могут кэшироваться. При несовпадении метаданных ресурса с соответствующей информацией в кэше копия ресурса помечается как устаревшая. |
| **POST**    | Применяется для передачи пользовательских данных заданному ресурсу. Например, в блогах посетители обычно могут вводить свои комментарии к записям в HTML-форму, после чего они передаются серверу методом POST и он помещает их на страницу. При этом передаваемые данные (в примере с блогами — текст комментария) включаются в тело запроса. Аналогично с помощью метода POST обычно загружаются файлы.В отличие от метода GET, метод POST не считается идемпотентным[4], то есть многократное повторение одних и тех же запросов POST может возвращать разные результаты (например, после каждой отправки комментария будет появляться одна копия этого комментария).При результатах выполнения 200 (Ok) и 204 (No Content) в тело ответа следует включить сообщение об итоге выполнения запроса. Если был создан ресурс, то серверу следует вернуть ответ 201 (Created) с указанием URI нового ресурса в заголовке Location.Сообщение ответа сервера на выполнение метода POST не кэшируется. |
| **PUT**     | Применяется для загрузки содержимого запроса на указанный в запросе URI. Если по заданному URI не существовало ресурса, то сервер создаёт его и возвращает статус 201 (Created). Если же был изменён ресурс, то сервер возвращает 200 (Ok) или 204 (No Content). Сервер не должен игнорировать некорректные заголовки Content-* передаваемые клиентом вместе с сообщением. Если какой-то из этих заголовков не может быть распознан или не допустим при текущих условиях, то необходимо вернуть код ошибки 501 (Not Implemented).Фундаментальное различие методов POST и PUT заключается в понимании предназначений URI ресурсов. Метод POST предполагает, что по указанному URI будет производиться обработка передаваемого клиентом содержимого. Используя PUT, клиент предполагает, что загружаемое содержимое соответствуют находящемуся по данному URI ресурсу.Сообщения ответов сервера на метод PUT не кэшируются. |
| **PATCH**   | Аналогично PUT, но применяется только к фрагменту ресурса.   |
| **DELETE**  | Удаляет указанный ресурс.                                    |
| **TRACE**   | Возвращает полученный запрос так, что клиент может увидеть, что промежуточные сервера добавляют или изменяют в запросе. |
| **LINK**    | Устанавливает связь указанного ресурса с другими.            |
| **UNLINK**  | Убирает связь указанного ресурса с другими.                  |

Каждый сервер обязан поддерживать как минимум методы GET и HEAD. Если сервер не распознал указанный клиентом метод, то он должен вернуть статус 501 (Not Implemented). Если серверу метод известен, но он не применим к конкретному ресурсу, то возвращается сообщение с кодом 405 (Method Not Allowed). В обоих случаях серверу следует включить в сообщение ответа заголовок Allow со списком поддерживаемых методов.

Наиболее востребованными являются методы GET и POST — на человеко-ориентированных ресурсах, POST — роботами поисковых машин и оффлайн-браузерами.

**Прокси-сервер**

Прокси - это транзитный сервер, перенаправляющий HTTP-трафик. Прокси-серверы используются для ускорения выполнения запросов путем кэширования веб-страниц. В локальной сети применяется как межсетевой экран и средство управления HTTP-трафиком (например, для блокирования доступа к некоторым ресурсам). В Интернете прокси часто используют для анонимизации запросов - в этом случае веб-сервер получает ip-адрес прокси-сервера, а не реального клиента. В современных браузерах можно задать целый список прокси и переключаться между серверами из этого списка по мере необходимости (обычно такая возможность доступна через расширения или плагины браузера).

### Коды состояния

**Код состояния** информирует клиента о результатах выполнения запроса и определяет его дальнейшее поведение. Набор кодов состояния является стандартом, и все они описаны в соответствующих документах RFC.

Каждый код представляется целым трехзначным числом. Первая цифра указывает на класс состояния, последующие - порядковый номер состояния (рис 1.). За кодом ответа обычно следует краткое описание на английском языке.

![../_images/status.gif](https://iit-web-lectures.readthedocs.io/ru/latest/_images/status.gif)

Рис. 1. Структура кода состояния HTTP

Введение новых кодов должно производиться только после согласования с IETF. Клиент может не знать все коды состояния, но он обязан отреагировать в соответствии с классом кода.

Применяемые в настоящее время классы кодов состояния и некоторые примеры ответов сервера приведены в табл. 2.

Таблица 2. Коды состояния протокола HTTP

| Класс кодов                            | Краткое описание                                             |
| :------------------------------------- | :----------------------------------------------------------- |
| **1xx Informational** (Информационный) | В этот класс выделены коды, информирующие о процессе передачи. В HTTP/1.0 сообщения с такими кодами должны игнорироваться. В HTTP/1.1 клиент должен быть готов принять этот класс сообщений как обычный ответ, но ничего отправлять серверу не нужно. Сами сообщения от сервера содержат только стартовую строку ответа и, если требуется, несколько специфичных для ответа полей заголовка. [Прокси-сервера](https://iit-web-lectures.readthedocs.io/ru/latest/www/http.html#proxy) подобные сообщения должны отправлять дальше от сервера к клиенту.Примеры ответов сервера:`100 Continue (Продолжать) 101 Switching Protocols (Переключение протоколов) 102 Processing (Идёт обработка) ` |
| **2xx Success** (Успешно)              | Сообщения данного класса информируют о случаях успешного принятия и обработки запроса клиента. В зависимости от статуса сервер может ещё передать заголовки и тело сообщения.Примеры ответов сервера:`200 OK (Успешно). 201 Created (Создано) 202 Accepted (Принято) 204 No Content (Нет содержимого) 206 Partial Content (Частичное содержимое) ` |
| **3xx** Redirection (Перенаправление)  | Коды статуса класса 3xx сообщают клиенту, что для успешного выполнения операции нужно произвести следующий запрос к другому URI. В большинстве случаев новый адрес указывается в поле Location заголовка. Клиент в этом случае должен, как правило, произвести автоматический переход (жарг. «редирект»).Обратите внимание, что при обращении к следующему ресурсу можно получить ответ из этого же класса кодов. Может получиться даже длинная цепочка из перенаправлений, которые, если будут производиться автоматически, создадут чрезмерную нагрузку на оборудование. Поэтому разработчики протокола HTTP настоятельно рекомендуют после второго подряд подобного ответа обязательно запрашивать подтверждение на перенаправление у пользователя (раньше рекомендовалось после 5-го). За этим следить обязан клиент, так как текущий сервер может перенаправить клиента на ресурс другого сервера. Клиент также должен предотвратить попадание в круговые перенаправления.Примеры ответов сервера:`300 Multiple Choices (Множественный выбор) 301 Moved Permanently (Перемещено навсегда) 304 Not Modified (Не изменялось) ` |
| **4xx Client Error** (Ошибка клиента)  | Класс кодов 4xx предназначен для указания ошибок со стороны клиента. При использовании всех методов, кроме HEAD, сервер должен вернуть в теле сообщения гипертекстовое пояснение для пользователя.Примеры ответов сервера:`401 Unauthorized (Неавторизован) 402 Payment Required (Требуется оплата) 403 Forbidden (Запрещено) 404 Not Found (Не найдено) 405 Method Not Allowed (Метод не поддерживается) 406 Not Acceptable (Не приемлемо) 407 Proxy Authentication Required (Требуется аутентификация прокси) ` |
| **5xx Server Error** (Ошибка сервера)  | Коды 5xx выделены под случаи неудачного выполнения операции по вине сервера. Для всех ситуаций, кроме использования метода HEAD, сервер должен включать в тело сообщения объяснение, которое клиент отобразит пользователю.Примеры ответов сервера:`500 Internal Server Error (Внутренняя ошибка сервера) 502 Bad Gateway (Плохой шлюз) 503 Service Unavailable (Сервис недоступен) 504 Gateway Timeout (Шлюз не отвечает) ` |

## Заголовки HTTP

**Заголовок HTTP** (HTTP Header) — это строка в HTTP-сообщении, содержащая разделённую двоеточием пару вида «параметр-значение». Формат заголовка соответствует общему формату заголовков текстовых сетевых сообщений ARPA (RFC 822). Как правило, браузер и веб-сервер включают в сообщения более чем по одному заголовку. Заголовки должны отправляться раньше тела сообщения и отделяться от него хотя бы одной пустой строкой (CRLF).

Название параметра должно состоять минимум из одного печатного символа (ASCII-коды от 33 до 126). После названия сразу должен следовать символ двоеточия. Значение может содержать любые символы ASCII, кроме перевода строки (CR, код 10) и возврата каретки (LF, код 13).

Пробельные символы в начале и конце значения обрезаются. Последовательность нескольких пробельных символов внутри значения может восприниматься как один пробел. Регистр символов в названии и значении не имеет значения (если иное не предусмотрено форматом поля).

Пример заголовков ответа сервера:

```
Server: Apache/2.2.3 (CentOS)
Last-Modified: Wed, 09 Feb 2011 17:13:15 GMT
Content-Type: text/html; charset=UTF-8
Accept-Ranges: bytes
Date: Thu, 03 Mar 2011 04:04:36 GMT
Content-Length: 2945
Age: 51
X-Cache: HIT from proxy.omgtu
Via: 1.0 proxy.omgtu (squid/3.1.8)
Connection: keep-alive

200 OK
```

Все HTTP-заголовки разделяются на четыре основных группы:

1. General Headers (Основные заголовки) — должны включаться в любое сообщение клиента и сервера.
2. Request Headers (Заголовки запроса) — используются только в запросах клиента.
3. Response Headers (Заголовки ответа) — присутствуют только в ответах сервера.
4. Entity Headers (Заголовки сущности) — сопровождают каждую сущность сообщения.

**Сущности** (entity, в переводах также встречается название “объект”) — это полезная информация, передаваемая в запросе или ответе. Сущность состоит из метаинформации (заголовки) и непосредственно содержания (тело сообщения).

В отдельный класс заголовки сущности выделены, чтобы не путать их с заголовками запроса или заголовками ответа при передаче множественного содержимого (multipart/[*](https://iit-web-lectures.readthedocs.io/ru/latest/www/http.html#id6)). Заголовки запроса и ответа, как и основные заголовки, описывают всё сообщение в целом и размещаются только в начальном блоке заголовков, в то время как заголовки сущности характеризуют содержимое каждой части в отдельности, располагаясь непосредственно перед её телом.

В таблице 3 приведено краткое описание некоторых HTTP-заголовков.

Таблица 3. Заголовки HTTP

| Заголовок           | Группа   | Краткое описание                                             |
| :------------------ | :------- | :----------------------------------------------------------- |
| Allow               | Entity   | Список методов, применимых к запрашиваемому ресурсу.         |
| Content-Encoding    | Entity   | Применяется при необходимости перекодировки содержимого (например, gzip/deflated). |
| Content-Language    | Entity   | Локализация содержимого (язык(и))                            |
| Content-Length      | Entity   | Размер тела сообщения (в октетах)                            |
| Content-Range       | Entity   | Диапазон (используется для поддержания многопоточной загрузки или дозагрузки) |
| Content-Type        | Entity   | Указывает тип содержимого (mime-type, например text/html).Часто включает указание на таблицу символов локали (charset) |
| Expires             | Entity   | Дата/время, после которой ресурс считается устаревшим. Используется прокси-серверами |
| Last-Modified       | Entity   | Дата/время последней модификации сущности                    |
| Cache-Control       | General  | Определяет директивы управления механизмами кэширования. Для прокси-серверов. |
| Connection          | General  | Задает параметры, требуемые для конкретного соединения.      |
| Date                | General  | Дата и время формирования сообщения                          |
| Pragma              | General  | Используется для специальных указаний, которые могут (опционально) применяется к любому получателю по всей цепочке запросов/ответов (например, pragma: no-cache). |
| Transfer-Encoding   | General  | Задает тип преобразования, применимого к телу сообщения. В отличие от Content-Encoding этот заголовок распространяется на все сообщение, а не только на сущность. |
| Via                 | General  | Используется шлюзами и прокси для отображения промежуточных протоколов и узлов между клиентом и веб-сервером. |
| Warning             | General  | Дополнительная информация о текущем статусе, которая не может быть представлена в сообщении. |
| Accept              | Request  | Определяет применимые типы данных, ожидаемых в ответе.       |
| Accept-Charset      | Request  | Определяет кодировку символов (charset) для данных, ожидаемых в ответе. |
| Accept-Encoding     | Request  | Определяет применимые форматы кодирования/декодирования содержимого (напр, gzip) |
| Accept-Language     | Request  | Применимые языки. Используется для согласования передачи.    |
| Authorization       | Request  | Учетные данные клиента, запрашивающего ресурс.               |
| From                | Request  | Электронный адрес отправителя                                |
| Host                | Request  | Имя/сетевой адрес [и порт] сервера. Если порт не указан, используется 80. |
| If-Modified-Since   | Request  | Используется для выполнения условных методов (Если-Изменился...). Если запрашиваемый ресурс изменился, то он передается с сервера, иначе - из кэша. |
| Max-Forwards        | Request  | Представляет механиз ограничения количества шлюзов и прокси при использовании методов TRACE и OPTIONS. |
| Proxy-Authorization | Request  | Используется при запросах, проходящих через прокси, требующие авторизации |
| Referer             | Request  | Адрес, с которого выполняется запрос. Этот заголовок отсутствует, если переход выполняется из адресной строки или, например, по ссылке из js-скрипта. |
| User-Agent          | Request  | Информация о пользовательском агенте (клиенте)               |
| Location            | Response | Адрес перенаправления                                        |
| Proxy-Authenticate  | Response | Сообщение о статусе с кодом 407.                             |
| Server              | Response | Информация о программном обеспечении сервера, отвечающего на запрос (это может быть как веб- так и прокси-сервер). |

В листинге 1 приведен фрагмент дампа заголовков при подключении к серверу [http://example.org](http://example.org/)

Листинг 1. Заголовки HTTP

```
http://www.example.org/

GET http://www.example.org/ HTTP/1.1
Host: www.example.org
User-Agent: Mozilla/5.0 (X11; U; Linux i686; ru; rv:1.9.2.13) Gecko/20101203 SUSE/3.6.13-0.2.1 Firefox/3.6.13
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: ru-ru,ru;q=0.8,en-us;q=0.5,en;q=0.3
Accept-Encoding: gzip,deflate
Accept-Charset: windows-1251,utf-8;q=0.7,*;q=0.7
Keep-Alive: 115
Proxy-Connection: keep-alive

HTTP/1.0 302 Moved Temporarily
Date: Thu, 03 Mar 2011 06:48:28 GMT
Location: http://www.iana.org/domains/example/
Server: BigIP
Content-Length: 0
X-Cache: MISS from proxy.omgtu
Via: 1.0 proxy.omgtu (squid/3.1.8)
Connection: keep-alive
----------------------------------------------------------
http://www.iana.org/domains/example/

GET http://www.iana.org/domains/example/ HTTP/1.1
Host: www.iana.org
User-Agent: Mozilla/5.0 (X11; U; Linux i686; ru; rv:1.9.2.13) Gecko/20101203 SUSE/3.6.13-0.2.1 Firefox/3.6.13
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: ru-ru,ru;q=0.8,en-us;q=0.5,en;q=0.3
Accept-Encoding: gzip,deflate
Accept-Charset: windows-1251,utf-8;q=0.7,*;q=0.7
Keep-Alive: 115
Proxy-Connection: keep-alive

HTTP/1.0 200 OK
Server: Apache/2.2.3 (CentOS)
Last-Modified: Wed, 09 Feb 2011 17:13:15 GMT
Content-Type: text/html; charset=UTF-8
Accept-Ranges: bytes
Date: Thu, 03 Mar 2011 04:04:36 GMT
Content-Length: 2945
Age: 9858
X-Cache: HIT from proxy.omgtu
Via: 1.0 proxy.omgtu (squid/3.1.8)
Connection: keep-alive

....
```

Несколько полезных примеров php-скриптов, обрабатывающих HTTP-заголовки, приведены в статье «Использование файла .htaccess» (редирект, отправка кода ошибки, установка last-modified и т.п.).



### Описание протокола SMTP

Протокол SMTP был разработан для работы в различных сетях для транспортировки электронной почты. Однако одной из наиболее широко используемых стала сеть Internet, с установкой соединения TCP/IP через порт 25. Большинство версий ОС Linux автоматически устанавливают программный пакет по поддержке SMTP при установке различных сервисов. Для того чтобы убедиться в способности удаленного сервера работать по протоколу SMTP, можно войти на его порт 25, воспользовавшись программой telnet. Если будет получен ответ с этого порта, то на сервере запущен протокол SMTP. На локальном сервере можно проделать тоже самое, подключившись с помощью telnet на порт 25 на localhost. Пример сеанса telnet с сервером на базе ОС Linux показан в листинге 5.1.



```
1 [jessica@shadrach jessica]$ telnet localhost 25
2 Trying 127.0.0.1...
3 Connected to localhost.
4 Escape character is '^]'.
5 220 shadrach.smallorg.org ESMTP Sendmail 8.9.3/8.9.3; Wed, 25 Aug 1999 18:35:33 -0500
6 QUIT
7 221 shadrach.smallorg.org closing connection
8 Connection closed by foreign host.
9 [jessica@shadrach jessica]$
```

Листинг 5.1. Пример сеанса telnet с портом 25

В строке 1 показан формат команды telnet с использованием хоста localhost и TCP-порта 25. В строке 5 показан типичный ответ сервера с ОС Linux, на котором установлен программный пакет для работы SMTP. Число, с которого начинается ответ, является трехзначным кодом ответа. Этот код может использоваться при поиске и устранении неполадок в работе электронной почты. Далее следует имя сервера SMTP и описание программного пакета SMTP, который распространяется организацией Sendmail Consortium. Строка 6 содержит команду QUIT на закрытие сеанса telnet. После этого сервер SMTP должен выдать сообщение о закрытии сеанса и разорвать TCP-соединение. Из данного примера можно сделать вывод о том, что протокол SMTP использует простые текстовые команды в формате ASCII и возвращает трехзначные кодированные ответы с текстовыми сообщениями. Протокол SMTP описывается документом Internet Request For Comment (RFC) номер 821, который был разработан группой Internet Engineering Task Force (IETF) и опубликован 21 августа 1982 года. С тех пор он претерпел несколько модификаций, но в целом основные команды протокола не изменились.



# Основные команды клиента SMTP

После установления сеанса TCP сервер SMTP посылает клиенту специальное сообщение об установке соединения (как это показано в листинге 5.1). С этого момента управление соединением между двумя компьютерами осуществляется клиентом, подключившимся к серверу. Клиент управляет соединением при помощи набора специальных команд, которые он посылает серверу. Сервер, в свою очередь, должен соответствующим образом ответить на каждую посланную ему команду. В RFC 821 описаны основные команды для клиента SMTP, на которые сервер должен реагировать определенным образом. Хотя с момента создания этого документа появилось несколько расширений к протоколу SMTP, они пока поддерживаются не всеми почтовыми серверами. В этом разделе мы выделим лишь основные команды SMTP, определенные в RFC 821. В разделе "Расширения протокола SMTP" рассматриваются некоторые дополнения, реализованные в последних версиях пакета SMTP.

Формат команд в SMTP прост:

```
command [parameter],
```

где command — четырехсимвольная команда протокола SMTP, а parameter — необязательный параметр, определяющий тип данных в команде. В [табл. 5.1](https://www.intuit.ru/studies/courses/116/116/lecture/3363?page=1#table.5.1) приведены основные команды протокола SMTP. Далее мы рассмотрим эти команды более детально.



| Команда |                     Описание                     |
| :-----: | :----------------------------------------------: |
|  HELO   |         Открывает приглашение от клиента         |
|  MAIL   |         Определяет отправителя сообщения         |
|  RCPT   |         Определяет получателей сообщения         |
|  DATA   |           Определяет начало сообщения            |
|  SEND   |          Посылает сообщение на терминал          |
|  SOML   |                   Send-or-Mail                   |
|  SAML   |                  Send-and-Mail                   |
|  RSET   |              Сброс SMTP-соединения               |
|  VRFY   |        Проверяет имя пользователя системы        |
|  EXPN   |          Запрашивает список псевдонимов          |
|  HELP   |            Запрашивает список команд             |
|  NOOP   |         No operation — Ничего не делать          |
|  QUIT   |              Остановить сеанс SMTP               |
|  TURN   | Реверс ролей в SMTP (клиент становится сервером) |



## Команда HELO

По определению, длина команд протокола SMTP четыре символа. Приветствие, выдаваемое клиентом на сервер, и есть команда HELO. Формат команды следующий:

```
HELO domain name
```

Смысл команды HELO заключается в представлении клиента серверу SMTP. К сожалению, этот метод доступа был разработан на начальной стадии развития сети Internet, когда еще не было столь большого числа попыток несанкционированного проникновения в компьютерные системы. Как видите, клиент может назвать себя любым именем в командной строке. Это привело к тому, что в настоящее время большинство серверов SMTP эту команду используют чисто формально. Если они действительно стараются идентифицировать клиента, то подключается механизм обратного преобразования DNS с целью определения действительного имени хоста клиента согласно системе доменных имен по его IP-адресу. Как правило, в целях безопасности серверы SMTP отказывают в установлении соединения хостам, IP-адрес которых не преобразуется в соответствующее имя хоста. Посылая данную команду, клиент уведомляет сервер о желании установить с ним соединение. Отвечая на эту команду, сервер, в свою очередь, уведомляет об установке нового соединения с клиентом и готовности принимать от него последующие команды.

### **Пользователи-клиенты и хосты-клиенты**

При работе с протоколом SMTP следует различать клиентов SMTP. Пользователи-клиенты и хосты-клиенты не одно и то же. При создании почтового сообщения пользователь системы электронной почты является одновременно и клиентом своего локального хоста. После отправки почтового сообщения он уже не является клиентом процесса SMTP. Теперь его локальный хост-компьютер осуществляет процесс доставки сообщения и сам выступает в качестве клиента SMTP. Когда локальный хост соединяется с удаленным хостом для передачи сообщения с помощью протокола SMTP, он действует как клиент SMTP-процесса. Команда HELO объявляет в качестве клиента имя локального хоста, а не реального пользователя, отославшего сообщение. Довольно часто эти понятия путают, что усложняет решение проблем, возникающих в системах электронной почты.



## Команда MAIL

Команда MAIL используется для организации сеанса обмена электронной почтой с сервером после того, как была послана команда HELO. Она указывает, от кого исходит данное сообщение. Формат команды MAIL следующий:

```
MAIL reverse-path
```

Аргумент reverse-path не только определяет отправителя сообщения, но также указывает маршрут, по которому можно вернуть сообщение в случае невозможности его доставки. Если отправитель является пользователем на клиентском компьютере, который инициировал сеанс SMTP, то формат команды будет следующим:

```
MAIL FROM: rich@shadrach.smallorg.org
```

Заметьте, что в поле FROM указывается адрес электронной почты отправителя сообщения, включая полное имя клиентского хост-компьютера. Эта информация должна присутствовать в поле FROM почтового сообщения (но об этом позже). Если почтовое сообщение проходило на пути от отправителя к получателю через несколько узлов, то каждый из них будет добавлять сведения о себе в поле <reverse-path>. Таким образом документируется путь прохождения сообщения через почтовые серверы. Довольно часто электронная почта от клиентов частных сетей должна проходить через несколько серверов электронной почты, прежде чем попасть в сеть Internet. Информация, которая содержится в поле reverse-path часто полезна при разрешении проблем в системах электронной почты или для обнаружения почтовых серверов, которые пытаются скрыть свою принадлежность, посылая сообщения через неизвестные серверы SMTP.



# TELNET 

TELNET — это сокращение от Terminals NETwork. Это стандартный протокол TCP/IP для услуг виртуального терминала. TELNET дает возможность устанавливать соединение с удаленным компьютером таким образом, что создается впечатление, как будто местный терминал – это терминал удаленной системы.



## Концепция

TELNET основан на концепциях, которые обсуждаются ниже.



## Внешняя среда с разделением времени

TELNET был разработан в эпоху, когда большие операционные системы, такие как UNIX, работали с внешней средой по принципу разделения времени. Согласно этому принципу, большой компьютер поддерживал множество пользователей, предоставляя им часть общего времени. Взаимодействие между пользователем и компьютером осуществляется с помощью терминала, который обычно состоит из комбинации клавиатуры, монитора и мышки. Даже микрокомпьютер может моделировать терминал с помощью терминального эмулятора.

В среде с разделением времени вся обработка информации проводится в центральном компьютере. Когда пользователь печатает символ на клавиатуре, символ обычно посылается компьютеру и отражается на мониторе. Разделение по времени создается средой, в которой для каждого пользователя создается иллюзия специализированного компьютера. Пользователь выполняет программу доступа к системным ресурсам, переключается от одной программы к другой и так далее.



## Логин

В среде с разделением времени пользователь — это часть системы с некоторыми правами и, вероятно, с паролем. Каждый полномочный пользователь имеет идентификатор и пароль. Пользовательская идентификация определяет пользователя как часть системы. Для доступа к системе пользователь начинает сеанс с пользовательского идентификатора (id) или с регистрационного имени (login name). Система помогает проверке пароля, чтобы предотвратить доступ к ресурсу неполномочного пользователя.



## Местный логин

Когда пользователь входит в местную систему с разделением времени, это называется местный логин. Как только пользователь напечатает некое слово на терминале или рабочей станции, выполняющей эмуляцию терминала, сразу начинает работать терминальная программа (драйвер), которая распознает значение введенных символов. Терминальный драйвер передает символы операционной системе, в рамках этой системы комбинация символов интерпретируется и вызывает желаемую прикладную программу или утилиту ([рис. 12.1 ](https://www.intuit.ru/studies/professional_retraining/942/courses/2/lecture/50?page=1#image.12.1)).



![Местный login](https://www.intuit.ru/EDI/17_07_20_1/1594937994-30092/tutorial/13/objects/12/files/12-1.gif)


**Рис. 12.1.** Местный login

Однако этот механизм не такой простой, как кажется, потому что операционная система может назначить специальные значения для специальных символов. Скажем, в UNIX некоторые комбинации символов имеют специальное значение, например, комбинации управляющих символов с символом "z", которые означают прекращение действия; комбинации управляющих символов с символом "c" означают остановку; и так далее. Несмотря на то что эти специальные ситуации не создают никаких проблем в местном вхождении в систему (login), потому что терминальный эмулятор и терминальный драйвер знают точно значение каждого символа и комбинации символов, они могут создавать проблемы при удаленном входе в систему. Какой процесс должен интерпретировать специальные символы? Клиент или сервер? Эта ситуация будет рассмотрена в этой лекции позднее.



## Удаленный логин

Когда пользователь хочет иметь доступ к прикладной программе или утилите, размещенным на удаленном компьютере, он выполняет дистанционный вход в систему (логин). Здесь TELNET берет на себя функции клиента и сервера. Пользователь посылает сигнал нажатия кнопки терминальному драйверу, где местная операционная система принимает символы и интерпретирует их. Эти символы посылает TELNET-клиент, который преобразует символы к универсальному набору, называемому символы виртуального сетевого терминала (Network Virtual Terminal Characters), и доставляет их к местному стеку протоколов TCP/IP ([рис. 12.2 ](https://www.intuit.ru/studies/professional_retraining/942/courses/2/lecture/50?page=1#image.12.2)).



![Дистанционный login](https://www.intuit.ru/EDI/17_07_20_1/1594937994-30092/tutorial/13/objects/12/files/12-2.gif)


**Рис. 12.2.** Дистанционный login

Команды или текст в форме сетевого виртуального терминала (NVT) перемещаются через Интернет и прибывают на стек протоколов TCP/IP в удаленной машине. Здесь символы доставляются операционной системе и проходят к TELNET-серверу, который преобразует их в символы, понятные удаленному компьютеру. Однако символы не могут пройти прямо на операционную систему, потому что удаленная операционная система не разработана для получения трактовки этих символов от TELNET. Она спроектирована так, чтобы принимать символы от драйвера терминала. Решение, добавляющее необходимое программное обеспечение, называется псевдотерминальным драйвером, который преобразовывает поступившие символы как символы, поступающие от местного терминала. Операционная система затем предает символы к соответствующей прикладной программе.



## Сетевой виртуальный терминал (NVT)

Механизм для доступа удаленного компьютера должен быть комплексным с учетом специфики каждой операционной системы. Например, для некоторых операционных систем знак конца — это Ctrl+z, в то время как в других операционных системах — это Ctrl+d.

Если мы хотим иметь доступ к любому удаленному компьютеру в мире, мы должны сначала знать специфику терминального эмулятора, используемую этим компьютером. TELNET решает эти проблемы определением универсального интерфейса, называемого NVT (Network Virtual Terminal — виртуальный сетевой терминал). Для каждого интерфейса TELNET переводит символы (данные или команды), которые получает от местного терминала, в NVT-форму и доставляет их в сеть. С другой стороны, сервер TELNET переводит команды из формы NVT в форму, доступную удаленному компьютеру. Все иллюстрации этой концепции смотрите на [рисунке 12.3.](https://www.intuit.ru/studies/professional_retraining/942/courses/2/lecture/50?page=1#image.12.3)



![Концепция NVT](https://www.intuit.ru/EDI/17_07_20_1/1594937994-30092/tutorial/13/objects/12/files/12-3.gif)

# Протокол FTP

Протокол передачи файлов (File Transfer Protocol – FTP) – это стандартный механизм для копирования файла от одного хоста другим [19]. Передача файлов от одного компьютера к другому – это одна из большого числа общих задач, выполнение которой ожидается от организованной сети и взаимодействия между сетями.

Хотя передача файлов от одной системы к другой кажется простой и прямолинейной задачей, вначале должны быть решены некоторые проблемы. Например, две системы могут использовать различные соглашения об именах файлов. Две системы могут иметь различные пути для представления текстов и данных. Две системы могут иметь различные структуры директорий. Все эти проблемы решает FTP очень простым и элегантным методом.

FTP отличается от других приложений типа клиент-сервер тем, что он устанавливает два соединения между хостами. Одно соединение применяется для передачи данных, другое — для управления информацией (команды и отклики). Разделение команд и передачи управляющих данных делает FTP более эффективным. Управление соединением использует очень простые правила для связи. Нам нужна для передачи только линия команд или линия откликов. С другой стороны, соединение для данных нуждается в более сложных правилах из-за разнообразия типов данных.

FTP использует два заданных порта: порт 21 для управления и порт 20 для передачи данных.

[Рисунок 13.1](https://www.intuit.ru/studies/courses/2/2/lecture/52?page=1#image.13.1) показывает базовую модель FTP. Клиент имеет три компоненты: пользовательский интерфейс, процесс управления клиентом и процесс передачи клиентских данных. Соединение для передачи сигналов управления происходит между процессами управления. Соединение для передачи данных делается для процессов обмена данными.



![FTP](https://www.intuit.ru/EDI/17_07_20_1/1594937994-30092/tutorial/13/objects/13/files/13-1.gif)


**Рис. 13.1.** FTP

Соединение передачи сигналов управления остается открытым в течение всей интерактивной сессии FTP. Соединение передачи данных каждый раз открывается командой, чтобы вызвать передаваемый файл, и затем закрывается, когда файл передан. Другими словами, когда пользователь начинает FTP-сессию, соединение для передачи сигналов управления открывается. Пока оно открывается, соединение для передачи данных может быть открыто и закрыто много раз, если передается несколько файлов.



## Соединения

Два FTP-соединения – для передачи команд управления и передачи данных — используют различные стратегии и различные номера портов.



### Соединение для передачи команд управления

Соединение для передачи команд управления создается тем же самым методом, что и другие соединения, рассмотренные далее. Имеется два шага:

1. сервер пассивно открывается, подключается к заданному порту и ждет клиента;
2. клиент использует временный порт, и сессия активно открывается.

Соединение для передачи команд управления остается открытым в течение всего процесса. Тип услуги, используемый в соответствии с IP-протоколом, – это минимизация задержки, потому что это диалоговая связь между пользователем (человеком) и сервером. Пользователи различного типа посылают команды и ожидают получение откликов без существенной задержки. [Рис. 13.2](https://www.intuit.ru/studies/courses/2/2/lecture/52?page=1#image.13.2) показывает начальное соединение между сервером и клиентом. Конечно, после начального соединения процесс сервера порождает "дочерние" процессы и назначает свободное обслуживание клиента "дочерним" процессом, использующим кратковременный порт.



![Открытие управляющего соединения](https://www.intuit.ru/EDI/17_07_20_1/1594937994-30092/tutorial/13/objects/13/files/13-2.gif)


**Рис. 13.2.** Открытие управляющего соединения



### Соединение для передачи данных

Соединение для передачи данных использует заданный порт 20. Однако создание соединения для передачи данных отличается от предыдущего. FTP создает соединение для передачи данных следующим образом:

1. Клиент (не сервер) вызывает пассивное открытие кратковременного порта. Это может быть сделано клиентом, потому что клиент вызывает команды для передачи файлов.
2. Клиент посылает номер этого порта серверу, используя команду PORT (ниже эта команда будет рассмотрена).
3. Сервер получает номер порта, вызывает активное открытие заданного порта 20 и получает номер временного порта.

Шаги для создания начального соединения для передачи данных показаны на [рис. 13.3.](https://www.intuit.ru/studies/courses/2/2/lecture/52?page=1#image.13.3) Позднее мы увидим, что эти шаги меняются, если используется команда PASV.



![Создание соединения для передачи данных](https://www.intuit.ru/EDI/17_07_20_1/1594937994-30092/tutorial/13/objects/13/files/13-3.gif)


**Рис. 13.3.** Создание соединения для передачи данных



## Установление соединения

Процессы FTP клиента и сервера, которые выполняются на различных компьютерах, могут устанавливать соединение друг с другом. Эти два компьютера могут использовать различные операционные системы, различные наборы символов, различные структуры и различные форматы файлов. FTP должен сделать совместимой всю эту неоднородность.

FTP обладает двумя различными подходами для управления соединением: одним для соединения для передачи команд управления и одним для передачи данных. Рассмотрим отдельно каждый метод.



## Связь по каналу (соединению) для передачи команд управления

FTP применяет те же самые методы, что TELNET или SMTP, для коммутации по установлению соединения для команд управления. Он использует набор символов NVT ASCII ([ Рисунок 13.4](https://www.intuit.ru/studies/courses/2/2/lecture/52?page=1#image.13.4)). Связь устанавливается с помощью команд и откликов. Посылается одна команда (отклик) в один момент времени. Каждая команда или отклик – это только короткая строка, так что мы можем не беспокоиться о формате файла или структуре файла. Каждая строка заканчивается двумя символами, обозначающими конец строки (возврат каретки и перевод строки).



![Использование соединения управления](https://www.intuit.ru/EDI/17_07_20_1/1594937994-30092/tutorial/13/objects/13/files/13-4.gif)


**Рис. 13.4.** Использование соединения управления



## Связь по каналу (соединению) передачи данных

Цель и реализация соединения для передачи данных отличается от соединения для сигналов управления. Мы хотим передать файлы по каналу для передачи данных. Клиент должен различать тип файла, который должен быть передан, структуру данных и режим передачи. Перед тем как передавать по каналу для передачи данных, мы подготавливаем передачу по каналу для сигналов управления. Проблема разнородности решается с помощью определения трех атрибутов: тип, структура данных и режим передачи ([ рисунок 13.5](https://www.intuit.ru/studies/courses/2/2/lecture/52?page=1#image.13.5)).



![Использование соединения для передачи данных](https://www.intuit.ru/EDI/17_07_20_1/1594937994-30092/tutorial/13/objects/13/files/13-5.gif)


**Рис. 13.5.** Использование соединения для передачи данных



## Тип файла

FTP может передавать через соединение для передачи данных следующие типы файлов:

- **ASCII-файл**. Это формат, используемый по умолчанию для трансляции текстовых файлов. Каждый символ закодирован с использованием NVT ASCII-символов. Передатчик преобразует файл из собственного представления в NVT ASCII, и приемник преобразует символы NVT ASCII в собственное представление.
- **EBCDIC-файл**. Если оба конца соединения используют кодирование EBCDIC, файл может быть передан с использованием EBCDIC-кодирования.
- **Image-файл**. Этот файл по умолчанию — формат для передачи двоичных файлов. Файл посылается как непрерывный поток бит без всякой интерпретации и кодирования. Он в большинстве случаев используется для передачи двоичных файлов, таких как компилированная программа.

Если файл закодирован в ASCII или EBCDIC, другие атрибуты должны дополняться, чтобы определить возможность печати файла:

1. Запрещенный для печати. Это формат по умолчанию для передачи текстовых файлов. Файл не содержит "вертикальных" спецификаций для печати. Это означает, что файл не может быть напечатан без предварительной обработки, потому что он не содержит символов, интерпретируемых для вертикального передвижения печатающей головки. Этот формат используется для файлов, которые будут накоплены и обработаны позднее.
2. TELNET. В этом формате файл содержит NVT ASCII вертикальные символы, такие, как CR (перевод каретки), LN (перевод строки), NL (новая строка) и VT (вертикальное табулирование). Эти файлы могут быть напечатаны после передачи



## Структура данных

FTP может передавать файл по соединению для передачи данных, используя одну из следующих интерпретаций структуры данных:

- **Файловая структура (по умолчанию)**. Этот файл не имеет структуры. Это непрерывный поток данных.
- **Структура записи**. Этот файл, разделенный внутри записи Он может быть использован только с текстовым файлом.
- **Страничная структура**. Это файл, разделенный на страницы, каждая страница имеет номер и заголовок страницы. Страницы могут быть накоплены или достигнуты с помощью произвольного или последовательного доступа.



## Режимы передачи

FTP может передавать файл по соединению для передачи данных, используя один из трех следующих режимов передачи:

- **Поточный режим**. Это режим по умолчанию. Данные доставляются от FTP к TCP как непрерывный поток данных. TCP отвечает за разбиение данных на сегменты соответствующего размера. Если данные — просто поток байтов (файловая структура), то не нужно никакого признака окончания файла. Окончание файла в этом случае — это разъединение соединения данных отправителем. Если данные разделены на записи (структура по записи), каждая запись будет иметь однобайтный символ окончания записи (EOR — end of record).
- **Блочный режим**. Данные могут быть доставлены от FTP и TCP в блоках. В этом случае блоку предшествует трехбайтный заголовок. Первый байт называется дескриптор блока, следующие два байта определяют размер блока в байтах.
- **Сжатый режим**. Если файл большой, данные могут быть сжаты. Метод сжатия использует нормальное кодирование длины. В этом методе последовательное повторное появление блока данных заменяется одним вхождением и числом повторений. В тексте файла это обычно пробел (пустоты). В двоичном файле нулевые символы обычно сжимаются.



## Команды обработки

FTP использует соединение управления для того, чтобы установить связь между процессом управления клиента. В течение этой связи команды посылаются от клиента к серверу, и отклики посылаются от сервера к клиенту ([ рисунок 13.6](https://www.intuit.ru/studies/courses/2/2/lecture/52?page=1#image.13.6)).



![Команды обработки](https://www.intuit.ru/EDI/17_07_20_1/1594937994-30092/tutorial/13/objects/13/files/13-6.gif)

**Рис. 13.6.** Команды обработки



# Описание протокола UUCP

Протокол UUCP был разработан в конце 70-х годов Майком Леском (Mike Lesk) в лаборатории компании AT&T Bell. Изначально он предназначался для передачи файлов и электронных сообщений между двумя UNIX-компьютерами. Соединение по протоколу UUCP включает в себя три фазы:

- подтверждение открытия соединения;
- передача данных;
- подтверждение закрытия соединения.

Поскольку протокол UUCP был разработан еще до появления концепции "клиент-сервер", его терминология несколько отличается от общепринятой. То, что сегодня мы называем сервером в терминах UUCP называется UUCP-ведомым ( **slave** ), а клиент называется UUCP-ведущим или главным ( **master** ), так как он управляет соединением в сеансе UUCP ([рис. 9.1](https://www.intuit.ru/studies/courses/116/116/lecture/3371?page=1#image.9.1)). Любой компьютер может начать соединение по UUCP. Какой из двух компьютеров будет ведущим, а какой ведомым, определяется при подтверждении открытия соединения. И конечно же, специально, чтобы еще больше все запутать, компьютеры в течение сеанса UUCP могут меняться ролями ведущий-ведомый.



![Фазы в сеансе UUCP](https://www.intuit.ru/EDI/04_05_16_6/1462314086-646/tutorial/214/objects/9/files/09_01.jpg)


**Рис. 9.1.** Фазы в сеансе UUCP



## Подтверждение открытия соединения

При подтверждении открытия соединения оба компьютера опираются на основные правила, касающиеся связи по UUCP. В течение фазы подтверждения открытия соединения посылается специальный пакет, который начинается символом шестнадцатеричное 0x10 и заканчивается символом шестнадцатеричное 0x00. Когда ведущий компьютер вызывает ведомый, тот должен ответить определенным пакетом:

```
Shere=hostname,
```

где hostname - UUCP-имя ведомого компьютера. UUCP-имя не имеет ничего общего с именем компьютера согласно системе DNS, хотя делаются попытки согласовать эти две системы имен путем введения в сети Internet специального домена uucp. Итак, ведущий компьютер, получив имя ведомого компьютера, должен ответить ему следующим образом:

```
Shostname=options,
```

где hostname - это уже UUCP-имя ведущего компьютера, а options - параметры, которые определяются двумя хостами. Все эти параметры представлены в [табл. 9.1](https://www.intuit.ru/studies/courses/116/116/lecture/3371?page=1#table.9.1).



| Параметр |                           Описание                           |
| :------: | :----------------------------------------------------------: |
|  -Qseq   |        Определяет вызов номера последовательности seq        |
| -xlevel  | Устанавливает режим отладки на ведомом компьютере равным level |
| -pgrade  | Устанавливает ведомому компьютеру режим передачи файлов только с приоритетом grade или выше |
|    -N    | Сигнализирует о том, что ведущий компьютер воспринимает расширения в соответствии с Taylor UUCP |

Ведомый компьютер, в свою очередь, должен ответить на параметр, заданный ведущим, определенным кодом. Коды ответов ведомого компьютера представлены в [табл. 9.2](https://www.intuit.ru/studies/courses/116/116/lecture/3371?page=1#table.9.2).



|       Код ответа       |                           Описание                           |
| :--------------------: | :----------------------------------------------------------: |
|          ROK           |                      Параметры опознаны                      |
|          ROKN          | То же, что и ROK, но принимаются расширения в соответствии с Taylor UUCP |
|          RLCK          | На ведомом компьютере ведущий с данным именем заблокирован - невозможно продолжить сеанс |
|          RCB           | Ведомый компьютер сбросит соединение и инициирует его в качестве ведущего |
|        RBADSEQ         | Номер последовательности в параметре -Q не опознан - попытка несанкционированного доступа |
|         RLOGIN         | Ведущий компьютер зарегистрировался на ведомом с ошибочным идентификатором входа в систему |
| RYou are unknown to me | В файлах config ведомого компьютера отсутствуют сведения о ведущем компьютере |

Если ведомый компьютер в ответе использовал код ROK или ROKN, то начинается следующий этап подтверждения открытия соединения. Если ведущий компьютер получил какой-либо другой код ответа, то он прекращает попытку соединения.

Следующий этап подтверждения открытия соединения заключается в согласовании параметров протокола UUCP двумя сторонами. На протяжении многих лет было разработано несколько методов инкапсуляции ядра протокола UUCP. Всем протоколам были присвоены буквы - от A до Z. Оригинальному протоколу UUCP была присвоена буква g. В то же время пакет Taylor UUCP, работая с таким же пакетом на другой машине, использует протокол i. В начале обмена ведомый компьютер посылает пакет:

```
Pprotocollist
```

Здесь под protocollist подразумевается список протоколов (в буквенном понимании), которые он поддерживает. Если ведущий компьютер обнаруживает в списке поддерживаемый им протокол, он отвечает пакетом:

```
Uprotocol,
```

где protocol - буквенное обозначение протокола, который ведущий компьютер желает использовать во время сеанса. Если не был найден приемлемый протокол для продолжения сеанса, то ведущий компьютер должен вернуть ответ типа UN и завершить соединение. Затем, после того как тип протокола выбран, компьютеры должны провести переговоры об индивидуальном протоколе (см. раздел "Типы протоколов UUCP" далее в этой лекции). После завершения переговоров фаза подтверждения открытия соединения окончена и начинается фаза передачи данных.

# Протокол Network News Transfer Protocol (NNTP)

Поскольку протокол доставки сетевых новостей NNTP приобретает все большую популярность, мы даем краткий обзор архитектуры этого протокола. Затем рассмотрим наиболее актуальные аспекты администрирования NNTP.



## Архитектура NNTP

Протокол NNTP задает способ распространения, запроса, поиска и доставки новостных статей в интернете. Клиент, которому нужно получать выборку подмножества статей в базе данных, называется подписчиком. NNTP позволяет подписчику запрашивать определенное подмножество статей, а не выполнять поиск всех статей из базы данных. До разработки протокола NNTP были популярны два метода распространения новостных элементов: почтовые списки рассылки инернета и система новостей Usenet.

Почтовый список рассылки интернета, известный под названием *сервера рассылки*,используется для распространения новостей с помощью списков рассылки электронной почты. Подписчик отправляет сообщение в список рассылки, и это сообщение передается по электронной почте всем членам списка. Но для отправки отдельной копии сообщения каждому подписчику требуется значительная часть пространства на диске, пропускной способности и ресурсов ЦП. Кроме того, для полного распространения сообщения тратится от нескольких минут до нескольких часов в зависимости от размера списка и наличия физических ресурсов, используемых для распространения. Поддержка списка подписчиков требует значительных затрат на администрирование, если только для автоматизации этой функции не используется программа сторонних фирм.

Хранение и считывание сообщений из центрального узла вместо отправки сообщения электронной почты каждому подписчику существенно снижает использование этих ресурсов. Эта альтернатива обеспечивается системой новостей Usenet. Кроме того, Usenet позволяет подписчику выбирать только те сообщения, которые он хочет прочитать, а также обеспечивает индексирование, перекрестные ссылки и следит за истечением срока хранения сообщений.

Протокол NNTP построен путем моделирования спецификаций новостей Usenet в документе RFC 850, но он имеет меньше требований к структуре, содержимому и хранению новостных статей. Он выполняется как фоновая служба на одном хосте и допускает соединения с другими хостами в локальной сети или через интернет. Когда подписчик подсоединяется к серверу NNTP, он передает команду NEWSGROUPS, чтобы определить, созданы ли на этом сервере новые группы новостей. Если да, то сервер уведомляет подписчика и пре-доставляет ему возможность подписаться на новые группы новостей. После этого подписчик подсоединяется к нужной группе новостей и с помощью команды NEWNEWS может выяснить, имеются ли новые статьи, поступившие после предыдущего подсоединения подписчика. Подписчик получает от сервера список новых статей и направляет запрос на передачу некоторых или всех статей. И, наконец, подписчик может ответить на новостную статью или поместить на сервер новую статью с помощью команды POST

NNTP использует для своих соединений протокол TCP и аналогичные SMTP команды и ответы. По умолчанию для NNTP используется ТСР-порт 119. Команды NNTP состоят из имени команды, после которого в некоторых случаях следует параметр. Они не зависят от регистра используемых букв. Каждая строка содержит только одну команду и не должна превышать 512 символов, включая пробелы, знаки пунктуации и конечные символы CR-LF (возврат каретки/перевод строки). Команды нельзя продолжать на следующей строке.

Ответ сервера содержит текст или информацию о состоянии. Текстовые ответы выводятся на экран в клиентской программе подписчика, а ответы с информацией о состоянии интерпретируются клиентской программой в отображение на экране.

Каждая строка с ответом о состоянии начинается с трехразрядного числового кода. Первая цифра ответа указывает на успешное выполнение, отказ или продолжение выполнения предыдущей команды. В таблице ([ таблица 7.5](https://www.intuit.ru/studies/courses/1114/301/lecture/7501?page=9#table.7.5)) приводится смысловое значение для первой цифры. Вторая цифра указывает функциональную категорию ответа. Эти категории приводятся ниже (см. [таблица 7.6](https://www.intuit.ru/studies/courses/1114/301/lecture/7501?page=9#table.7.6)). Третья цифра указывает конкретный ответ.



| Первая цифра |                      Смысловое значение                      |
| :----------: | :----------------------------------------------------------: |
|     1хх      |                   Информативное сообщение.                   |
|     2хх      |                   Успешный прием команды.                    |
|     Зхх      | Пока успешный прием команды; отправить остальную часть команды. |
|     4хх      | Команда передана правильно, но не может быть выполнена по некоторой причине. |
|     5хх      | Команда не реализована или неверна, либо произошла серьезная программная ошибка. |



| Вторая цифра |                   Смысловое значение                   |
| :----------: | :----------------------------------------------------: |
|     х0х      | Соединение, начальная установка и различные сообщения. |
|     x1x      |                 Выбор группы новостей.                 |
|     х2х      |                     Выбор статьи.                      |
|     хЗх      |                Функции распространения.                |
|     х4х      |       Размещение в группе новостей (публикация).       |
|     х8х      |     Нестандартные расширения (частная реализация).     |
|     х9х      |                 Отладочная информация.                 |

Обычно коды 2хх отправляются при начальном соединении с сервером NNTP в зависимости от разрешений доступа. Код 400 отправляется, когда сервер NNTP прерывает работу, а коды 5хх указывают, что команду нельзя выполнить по какой-то необычной причине. В таблице далее ([ таблица 7.7](https://www.intuit.ru/studies/courses/1114/301/lecture/7501?page=9#table.7.7)) приводится список некоторых кодов, с которыми вы столкнетесь при поиске и устранении проблем соединений NNTP.



|   Код   |                      Смысловое значение                      |
| :-----: | :----------------------------------------------------------: |
|   100   |                         Help-текст.                          |
| 190-199 |                    Отладочная информация.                    |
|   200   | Готовность сервера; размещение в группе новостей разрешено.  |
|   201   | Готовность сервера; размещение в группе новостей не разрешено. |
|   400   |                  Работа службы прекращена.                   |
|   500   |                  Нераспознаваемая команда.                   |
|   501   |                 Ошибка в синтаксисе команды.                 |
|   502   |        О граничение доступа или отказ в полномочиях.         |
|   503   |            Сбой программы; команда не выполнена.             |



## Команды NNTP

Мы не можем привести здесь подробное описание каждой команды протокола NNTP. Однако имеет смысл дать описание нескольких команд, с которыми вы столкнетесь и в журнале событий, и в выходном файле журнала, на тот случай, если вам понадобится искать и устранять проблемы соединений протокола NNTP. На [рис. 7.30](https://www.intuit.ru/studies/courses/1114/301/lecture/7501?page=9#image.7.30) приводятся некоторые команды.

Команды ARTICLE, BODY, HEAD и STAT относятся к поиску и передаче статьи новостей. Команды HEAD и BODY идентичны команде ARTICLE, за исключением того, что они возвращают либо строки заго-ловка (HEAD), либо основной текст (BODY) данной статьи. Команда STAT не возвращает никакого текста, а только идентификатор сообщения.

Команда ARTICLE имеет две формы: в первой из них вслед за командой указывается идентификатор сообщения для статьи, которую нужно вывести на экран, и вторая форма указывается с параметром или без параметра. В первой форме команды ARTICLE выводится заголовок, пустая строка и основной текст указанной статьи. Подписчик получает идентификатор сообщения из диапазона номеров статей, полученного в ответе на команду NEWNEWS.

Во второй форме команды, *ARTICLE <идентификатор сообщения>*, выводится заголовок, пустая строка и основной текст сообщения. Подписчик выбирает номер сообщения из полученного списка статей, когда была выбрана данная группа новостей. Если номер опущен, предполага-ется текущая статья. Вот некоторые ответы с сообщениями об ошибках, возникающие при использовании этой команды:

- "420 no current article has been selected" (не выбрана текущая статья);
- " 423 по such article number in this group" (статьи с таким номером нет в данной группе);
- " 430 no such article found" (не найдено такой статьи).



![ Файл журнала для службы NNTP ](https://www.intuit.ru/EDI/14_08_14_2/1407964674-31059/tutorial/457/objects/7/files/07_30.jpg)


**Рис. 7.30.** Файл журнала для службы NNTP

Команда GROUP должна сопровождаться именем группы новостей. Имена групп новостей не зависят от регистра используемых букв. Если запрашиваемая группа не существует, то подписчик получит сообщение об ошибке >"411 no such news group>" (Нет такой группы новостей). Если запрошенная группа существует, подписчик получит номера первой и последней статей в этой группе вместе с оценкой количества статей в группе. Эта оценка не обязательно в точности равна количеству статей.

Команда LIST возвращает список достоверных групп новостей и связанную с ними информацию. Для каждой группы передается строка текста, которая выглядит следующим образом:

<группа> <первая> <последняя> <р>

где

- <группа> > - имя группы новостей;
- <последняя> - номер последней известной статьи на данный момент в этой группе новостей;
- <первая> - номер первой статьи на данный момент в этой группе новостей;
- <р< - "у" или "п"; "у" указывает, что размещение (публикация) в группе новостей разрешено, а " п" указывает, что размещение не разрешено.

Возможно, что в ответе указано " у", но вы все равно не можете публиковаться в группе новостей, так как данная группа новостей либо мо-дерируется, либо имеет ограничения, либо отсоединилась по какой-либо причине.

Команда NEWSGROUPS сопровождается указанием даты, времени и необязательного параметра группы <рассылки> . Она выводит список групп новостей, созданных после указанных даты и времени. Дата указывается шестью цифрами в формате *ггммдд*. Ближайший век подразумевается первыми двумя цифрами. Так, 86 означает 1986, и 30 означает 2030. Параметр времени указывается шестью цифрами в формате *ччммсс*, причем часы указываются, исходя из 24 часов. Часовой пояс совпадает с часовым поясом сервера, если только не указана метка GMT, что соответствует времени на нулевом меридиане.

Необязательный параметр < *группы рассылки* > представляет список групп рассылки. Например, рассылочная часть net.trainsbydave -"net". При указании этого параметра рассылочная часть статьи сравнивается со списком групп рассылки. Выводятся только те группы, которые соответствуют указанным группам.



## Администрирование NNTP

Служба NNTP используется в Exchange Server 2003 для создания асинхронных групповых дискуссий. Она настраивается для взаимодействия с внешними серверами NNTP, чтобы сделать популярные группы Usenet доступными внутренним образом для пользователей системы. NNTP в IIS используется вместо службы Internet News Service в Exchange Server 5.5. При инсталляции Exchange Server 2003 эта система расширяет возможности NNTP в Windows 2003, придавая ему способность связываться с другими серверами новостей через каналы новостей.

Вы можете создать в своей организации несколько серверов NNTP в виде структуры "начальник-подчиненный" (master-subordinate). Это позволит клиентам подключаться к набору серверов и при этом поддерживать точные представления содержимого групп новостей. Создание набора серверов обеспечивает масштабируемость для большой пользовательской сети, такой как у провайдеров услуг интернета (ISP), и отказоустойчивость в случае отказа подчиненных серверов.

Несмотря на то что главный сервер управляет номерами статей и поддерживает синхронизацию с подчиненными серверами, клиенты всегда подсоединяются к подчиненному серверу новостей. Конфигурация DNS автоматически распределяет клиентскую нагрузку равномерно между подчиненными серверами. Поскольку каждый подчиненный сервер поддерживает канал новостей (newsf eed) с главным сервером, то новая опубликованная статья сначала передается на главный сервер и не появится на подчиненном сервере, пока главный сервер не отправит эту статью на все подчиненные серверы.

